// Generated by CoffeeScript 1.12.7
(function() {
  var Parser, root;

  Parser = (function() {
    function Parser() {
      this.events = [];
    }

    Parser.newEvent = function() {
      return {
        events: [],
        actions: [],
        effects: [],
        commands: []
      };
    };

    Parser.parse = function(lines) {
      var err, i, len, line, lineIdx, state;
      state = {
        indent: 0,
        events: [],
        errors: []
      };
      for (lineIdx = i = 0, len = lines.length; i < len; lineIdx = ++i) {
        line = lines[lineIdx];
        try {
          this.parseLine(line, lineIdx, state);
        } catch (error) {
          err = error;
          state.errors.push({
            lineIdx: lineIdx,
            text: "syntax error"
          });
        }
      }
      return [state.events, state.errors];
    };

    Parser.parseAtts = function(line) {
      var attrName, attrSet, attrVals, atts, i, len, ref, ref1;
      atts = {};
      ref = line.split(' ');
      for (i = 0, len = ref.length; i < len; i++) {
        attrSet = ref[i];
        ref1 = attrSet.split('='), attrName = ref1[0], attrVals = ref1[1];
        if (attrName[0] === '$') {
          attrName = attrName.slice(1);
        }
        atts[attrName] = attrVals.split('|').sample();
      }
      return atts;
    };

    Parser.parseLine = function(line, lineIdx, state) {
      var args, closedEvt, commentIdx, evt, peek, ref, rest, spaces;
      commentIdx = line.indexOf('#');
      if (commentIdx > -1) {
        line = line.slice(0, commentIdx);
      }
      ref = Parser.extract(line), spaces = ref[0], line = ref[1];
      if (line.length === 0) {
        return;
      }
      peek = line[0];
      rest = line.slice(1).trim();
      if (spaces < state.indent) {
        closedEvt = state.stack.pop().evt;
        if (closedEvt.events.length + closedEvt.actions.length === 0) {
          state.errors.push({
            lineIdx: lineIdx,
            text: "no actions or events defined"
          });
        }
      }
      if (spaces === 0) {
        evt = Parser.newEvent();
        evt.id = line;
        state.stack = [
          {
            spaces: 0,
            evt: evt
          }
        ];
        state.events.push(evt);
      } else if (peek === '-') {
        this.parseRef(rest, spaces, 'events', state);
      } else if (peek === '?') {
        this.parseRef(rest, spaces, 'actions', state);
      } else if (peek === '@') {
        this.parseRef(rest, spaces, 'effects', state);
      } else if (peek === ':') {
        args = rest.split(' ').map(function(arg) {
          return arg.trim();
        });
        state.stack.last().evt.commands.push({
          op: args[0],
          arg: args.slice(1).join(' ')
        });
      } else {
        evt = state.stack.last().evt;
        if (evt.actionText == null) {
          evt.actionText = evt.text;
        }
        evt.text = line;
      }
      return state.indent = spaces;
    };

    Parser.parseRef = function(line, spaces, collection, state) {
      var evt;
      if (spaces === state.stack.last().spaces) {
        state.stack.pop();
      }
      if (line[0] === '>') {
        evt = line.slice(1).trim();
        return state.stack.last().evt[collection].push({
          ref: evt
        });
      } else {
        evt = Parser.newEvent();
        state.stack.last().evt[collection].push(evt);
        state.stack.push({
          spaces: spaces,
          evt: evt
        });
        if (collection === 'actions') {
          return evt.actionText = line;
        } else {
          return evt.text = line;
        }
      }
    };

    Parser.extract = function(line) {
      var spaces;
      spaces = 0;
      line = line.replace('\t', '  ');
      while (line[0] === ' ') {
        spaces += 1;
        line = line.slice(1);
      }
      return [spaces, line.trim()];
    };

    return Parser;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Parser = Parser;

}).call(this);
