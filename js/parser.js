// Generated by CoffeeScript 1.6.2
(function() {
  var Parser, root;

  Parser = (function() {
    function Parser() {
      this.events = [];
    }

    Parser.newEvent = function() {
      return {
        events: [],
        actions: [],
        effects: [],
        commands: []
      };
    };

    Parser.parse = function(lines) {
      var line, state, _i, _len;

      state = {
        indent: 0,
        events: []
      };
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        this.parseLine(line, state);
      }
      return state.events;
    };

    Parser.parseAtts = function(line) {
      var attrName, attrSet, attrVals, atts, _i, _len, _ref, _ref1;

      atts = {};
      _ref = line.split(' ');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attrSet = _ref[_i];
        _ref1 = attrSet.split('='), attrName = _ref1[0], attrVals = _ref1[1];
        if (attrName[0] === '$') {
          attrName = attrName.slice(1);
        }
        atts[attrName] = attrVals.split('|').sample();
      }
      return atts;
    };

    Parser.parseLine = function(line, state) {
      var args, commentIdx, evt, peek, rest, spaces, _ref;

      commentIdx = line.indexOf('#');
      if (commentIdx > -1) {
        line = line.slice(0, commentIdx);
      }
      _ref = Parser.extract(line), spaces = _ref[0], line = _ref[1];
      if (line.length === 0) {
        return;
      }
      peek = line[0];
      rest = line.slice(1).trim();
      if (spaces < state.indent) {
        state.stack.pop();
      }
      if (spaces === 0) {
        evt = Parser.newEvent();
        evt.id = line;
        state.stack = [
          {
            spaces: 0,
            evt: evt
          }
        ];
        state.events.push(evt);
      } else if (peek === '-') {
        this.parseRef(rest, spaces, 'events', state);
      } else if (peek === '?') {
        this.parseRef(rest, spaces, 'actions', state);
      } else if (peek === '@') {
        this.parseRef(rest, spaces, 'effects', state);
      } else if (peek === ':') {
        args = rest.split(' ').map(function(arg) {
          return arg.trim();
        });
        state.stack.last().evt.commands.push({
          op: args[0],
          arg: args.slice(1).join(' ')
        });
      } else {
        evt = state.stack.last().evt;
        if (evt.actionText == null) {
          evt.actionText = evt.text;
        }
        evt.text = line;
      }
      return state.indent = spaces;
    };

    Parser.parseRef = function(line, spaces, collection, state) {
      var evt;

      if (spaces === state.stack.last().spaces) {
        state.stack.pop();
      }
      if (line[0] === '>') {
        evt = line.slice(1).trim();
        return state.stack.last().evt[collection].push({
          ref: evt
        });
      } else {
        evt = Parser.newEvent();
        state.stack.last().evt[collection].push(evt);
        state.stack.push({
          spaces: spaces,
          evt: evt
        });
        if (collection === 'actions') {
          return evt.actionText = line;
        } else {
          return evt.text = line;
        }
      }
    };

    Parser.extract = function(line) {
      var spaces;

      spaces = 0;
      line = line.replace('\t', '  ');
      while (line[0] === ' ') {
        spaces += 1;
        line = line.slice(1);
      }
      return [spaces, line.trim()];
    };

    return Parser;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Parser = Parser;

}).call(this);
