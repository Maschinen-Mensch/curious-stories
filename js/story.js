// Generated by CoffeeScript 1.10.0
(function() {
  var Story,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Story = (function() {
    function Story() {
      this.doEntityEffects = bind(this.doEntityEffects, this);
      this.reqs = new Requirements(this);
      this.effs = new Effects(this);
      this.setupExtensions();
      $('#game').hide();
    }

    Story.prototype.startGame = function() {
      var code, e, error;
      try {
        code = "[" + (window.firepad.getText()) + "]";
        acorn.parse(code);
        config.events = eval(code);
      } catch (error) {
        e = error;
        alert(e.message);
        return;
      }
      $('#firepad-container').hide();
      $('#help').hide();
      $('#game').empty().show();
      this.partyFlags = {};
      this.entities = [];
      return this.showEvent(config.events[0]);
    };

    Story.prototype.editGame = function() {
      $('#game').hide();
      $('#help').show();
      return $('#firepad-container').show();
    };

    Story.prototype.addEntity = function() {
      var key, newEntity, protoEntity, val;
      newEntity = new Entity();
      protoEntity = config.entities.sample();
      newEntity.name = TextHelper.parse(protoEntity.name);
      for (key in protoEntity) {
        val = protoEntity[key];
        if (key[0] === '$') {
          newEntity.attributes[key.slice(1)] = Core.randRange(val);
        }
      }
      return this.entities.push(newEntity);
    };

    Story.prototype.showEvent = function(eventId) {
      this.actions = [];
      this.doEvent(eventId);
      if (this.actions.length === 0) {
        return $('#game').append("<p><a class=start href='' onClick='startGame(); return false;'>New Game</a></p>");
      }
    };

    Story.prototype.doAction = function(actionIdx) {
      var action;
      action = this.actions[actionIdx];
      return this.showEvent(action);
    };

    Story.prototype.hasRequirements = function(eventIn, entity) {
      var event, key, val;
      event = Proto.getEvent(eventIn);
      for (key in event) {
        val = event[key];
        if (key.startsWith('req')) {
          Core.assert(this.reqs[key] != null, "Unknown requirement " + key);
          if (!this.reqs[key](val, entity)) {
            console.warn("failed requirement " + key + " for " + event.id);
            return false;
          }
        }
      }
      if (!this.doEntityEffects(event.entityEffects, true)) {
        return false;
      }
      return true;
    };

    Story.prototype.expandEvent = function(def) {
      if (def.ref != null) {
        return Proto.getEvent(def.ref);
      } else if (Object.isObject(def)) {
        return def;
      } else {
        return Proto.getEvent(def);
      }
    };

    Story.prototype.randEvent = function(eventSet, ctx) {
      var eventSlots, group, prio, randEvt, ref;
      ref = Core.arrify(eventSet).groupBy(function(e) {
        var ref;
        return (ref = e.prio) != null ? ref : 100;
      });
      for (prio in ref) {
        group = ref[prio];
        eventSlots = Core.arrify(group).map((function(_this) {
          return function(e) {
            var evt, ref1;
            evt = _this.expandEvent(e);
            return {
              evt: evt,
              canDo: _this.hasRequirements(evt),
              slots: (ref1 = e.slots) != null ? ref1 : 1
            };
          };
        })(this));
        eventSlots.remove(function(def) {
          return !def.canDo;
        });
        if (!eventSlots.isEmpty()) {
          break;
        }
      }
      if (eventSlots != null) {
        randEvt = this.randEntry(eventSlots);
        if (randEvt != null) {
          return randEvt.evt;
        }
      }
      return null;
    };

    Story.prototype.randEntry = function(slotDefs, ctx) {
      var entry, i, len, ref, targetChance, totalSlots;
      if (ctx == null) {
        ctx = {};
      }
      totalSlots = slotDefs.sum(function(e) {
        var ref;
        return (ref = e.slots) != null ? ref : 1;
      });
      targetChance = Math.random() * totalSlots;
      for (i = 0, len = slotDefs.length; i < len; i++) {
        entry = slotDefs[i];
        targetChance -= (ref = entry.slots) != null ? ref : 1;
        if (targetChance <= 0 || totalSlots === 0) {
          return entry;
        }
      }
      return null;
    };

    Story.prototype.doEffects = function(entry) {
      var key, val;
      for (key in entry) {
        val = entry[key];
        if (this.effs[key] != null) {
          this.effs[key](val);
        }
      }
    };

    Story.prototype.addText = function(txt, entities) {
      var text;
      if (entities == null) {
        entities = [];
      }
      if (txt != null) {
        text = TextHelper.parse(txt);
        text = TextHelper.replaceName(text, entities.map(function(ent) {
          return ent.name;
        }));
        return $('#game').append("<p>" + text + "</p>");
      }
    };

    Story.prototype.doEvent = function(eventIn, entity) {
      var action, actionId, event, i, len, nextEventRef, ref;
      event = Proto.getEvent(eventIn);
      if (event.id != null) {
        console.log("do event [" + event.id + "]");
      }
      $('#game .action').remove();
      if (entity == null) {
        this.addText(event.text);
      }
      this.doEffects(event);
      this.doEntityEffects(event.entityEffects);
      ref = Core.arrify(event.actions);
      for (i = 0, len = ref.length; i < len; i++) {
        actionId = ref[i];
        action = Proto.getEvent(actionId);
        if (this.hasRequirements(action)) {
          $('#game').append("<p class='action'> <a onClick=\"doAction('" + this.actions.length + "'); return false;\" href=''> " + action.actionText + " </a> </p>");
          this.actions.push(action);
        }
      }
      nextEventRef = this.randEvent(event.events);
      if (nextEventRef != null) {
        return this.doEvent(nextEventRef);
      }
    };

    Story.prototype.doEntityEffects = function(effects, testOnly) {
      var allEntities, consumedEntities, count, eff, ent, entities, evt, failed, i, j, len, len1, maxCount, minCount, optional, ref, ref1, ref2, ref3, ref4;
      if (testOnly == null) {
        testOnly = false;
      }
      if (effects == null) {
        return true;
      }
      consumedEntities = [];
      ref = Core.arrify(effects);
      for (i = 0, len = ref.length; i < len; i++) {
        eff = ref[i];
        optional = (ref1 = eff.optional) != null ? ref1 : false;
        if (optional && testOnly) {
          continue;
        }
        evt = this.expandEvent(eff);
        allEntities = this.entities;
        entities = allEntities.filter((function(_this) {
          return function(ent) {
            if (indexOf.call(consumedEntities, ent) >= 0) {
              return false;
            }
            return _this.hasRequirements(evt, ent);
          };
        })(this));
        count = (ref2 = evt.count) != null ? ref2 : 1;
        failed = false;
        if (count === 'all') {
          if (entities.length < allEntities.length) {
            if (optional) {
              continue;
            } else {
              return false;
            }
          }
        } else if (count === 'any') {

        } else {
          ref3 = Core.parseRange(count), minCount = ref3[0], maxCount = ref3[1];
          if (entities.length < minCount) {
            return false;
          }
          entities = entities.sample(maxCount);
        }
        if (entities.isEmpty()) {
          if (optional) {
            continue;
          } else {
            return false;
          }
        }
        if (!testOnly) {
          if ((evt.chance != null) && Math.random() > evt.chance) {
            continue;
          }
          this.addText(evt.text, entities);
          ref4 = entities.randomize();
          for (j = 0, len1 = ref4.length; j < len1; j++) {
            ent = ref4[j];
            this.doEvent(evt, ent);
            if (eff.consume) {
              consumedPersons.push(ch);
            }
          }
        }
      }
      return true;
    };

    Story.prototype.setupExtensions = function() {
      var evt, i, id, len, parentEvt, ref, ref1, ref2, results, slots;
      ref = config.events;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        evt = ref[i];
        if (evt["extends"] != null) {
          ref1 = evt["extends"].split(':'), id = ref1[0], slots = ref1[1];
          parentEvt = Proto.getEvent(id);
          if (parentEvt.events == null) {
            parentEvt.events = [];
          }
          results.push(parentEvt.events.push({
            ref: id,
            slots: (ref2 = parseInt(slots)) != null ? ref2 : 1
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Story;

  })();

  if (typeof window !== "undefined" && window !== null) {
    window.doAction = function(actionIdx) {
      window.story.doAction(actionIdx);
      return false;
    };
    window.startGame = function() {
      return window.story.startGame();
    };
    window.editGame = function() {
      return window.story.editGame();
    };
    window.help = function() {
      return window.story.showHelp();
    };
    window.onload = function() {
      return window.story = new Story;
    };
  }

}).call(this);
