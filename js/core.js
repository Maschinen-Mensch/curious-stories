// Generated by CoffeeScript 1.6.2
(function() {
  var Core, Proto, TextHelper, root;

  Proto = (function() {
    function Proto() {}

    Proto.getEvent = function(id) {
      var evt;

      if (Object.isObject(id)) {
        return id;
      }
      evt = config.events.filter(function(e) {
        return e.id === id;
      }).sample();
      Core.assert(evt != null, "Event with ID " + id + " not found");
      return evt;
    };

    return Proto;

  })();

  TextHelper = (function() {
    function TextHelper() {}

    TextHelper.replaceAtts = function(text, atts) {
      if (atts == null) {
        atts = {};
      }
      return text.replace(/\$\w+/g, function(match) {
        return atts[match.slice(1)];
      });
    };

    TextHelper.replaceName = function(text, names) {
      var i, name, nameTxt, _i, _len;

      if (names == null) {
        names = [];
      }
      names = Core.arrify(names);
      nameTxt = '';
      for (i = _i = 0, _len = names.length; _i < _len; i = ++_i) {
        name = names[i];
        if (names.length > 1 && i === names.length - 1) {
          nameTxt += ' and ';
        }
        nameTxt += name;
        if (i < names.length - 2) {
          nameTxt += ', ';
        }
      }
      text = text.replace('$name', nameTxt);
      if (names.length > 1) {
        text = text.replace('$is', "are");
        text = text.replace('$i', "we");
        text = text.replace('$I', "We");
      } else {
        text = text.replace('$is', "is");
        text = text.replace('$i', "I");
        text = text.replace('$I', "I");
      }
      return text;
    };

    TextHelper.parse = function(txt, gender) {
      var altTexts, match, matches, replacement, shortMatch, _i, _len;

      if (gender == null) {
        gender = 'male';
      }
      if (gender === 'female') {
        txt = txt.replace('$He', "She");
        txt = txt.replace('$His', "Her");
        txt = txt.replace('$Him', "Her");
        txt = txt.replace('$he', "she");
        txt = txt.replace('$his', "her");
        txt = txt.replace('$him', "her");
      } else {
        txt = txt.replace('$He', "He");
        txt = txt.replace('$His', "His");
        txt = txt.replace('$Him', "Him");
        txt = txt.replace('$he', "he");
        txt = txt.replace('$his', "his");
        txt = txt.replace('$him', "him");
      }
      matches = txt.match(/\[.*?\]/g);
      if (matches != null) {
        for (_i = 0, _len = matches.length; _i < _len; _i++) {
          match = matches[_i];
          shortMatch = match.slice(1, -1);
          altTexts = shortMatch.split('|');
          replacement = altTexts.length > 1 ? altTexts.sample() : Math.random() < 0.5 ? altTexts[0] : '';
          txt = txt.replace(match, replacement);
        }
      }
      return txt;
    };

    return TextHelper;

  })();

  Core = (function() {
    function Core() {}

    Core.arrify = function(ids, expandString) {
      if (expandString == null) {
        expandString = true;
      }
      if (ids == null) {
        return [];
      }
      if (expandString && Object.isString(ids)) {
        return ids.split(' ');
      }
      if (Object.isArray(ids)) {
        return ids;
      } else {
        return [ids];
      }
    };

    Core.strFlags = function(flags) {
      var entries, id, val;

      entries = [];
      for (id in flags) {
        val = flags[id];
        if (val) {
          entries.push(id);
        }
      }
      return entries.join(' ');
    };

    Core.setFlags = function(flagSet, actualFlags) {
      var flags;

      if (actualFlags == null) {
        actualFlags = {};
      }
      flags = this.parseFlags(flagSet).sample();
      return Object.merge(actualFlags, flags);
    };

    Core.parseFlags = function(flagSet, prefix) {
      var andSet, flag, flagGroup, orSet, _i, _j, _len, _len1, _ref, _ref1;

      if (prefix == null) {
        prefix = '';
      }
      if (Object.isString(flagSet)) {
        orSet = [];
        _ref = flagSet.split('|');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          flagGroup = _ref[_i];
          andSet = {};
          _ref1 = flagGroup.split(' ');
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            flag = _ref1[_j];
            flag = flag.trim();
            if (flag.length > 0) {
              Core.assert(flag[0] === '+' || flag[0] === '-', "flag " + flag + " needs to start with + or -");
              andSet[prefix + flag.slice(1)] = flag[0] === '+';
            }
          }
          orSet.push(andSet);
        }
        return orSet;
      } else {
        return Core.arrify(flagSet);
      }
    };

    Core.checkFlags = function(flagSet, actualFlags) {
      if (Object.isBoolean(flagSet)) {
        return flagSet;
      }
      flagSet = this.parseFlags(flagSet);
      return Core.arrify(flagSet).any(function(reqFlags) {
        return Object.all(reqFlags, function(id, val) {
          var entry, _ref;

          entry = (_ref = actualFlags[id]) != null ? _ref : false;
          return entry === val;
        });
      });
    };

    Core.parseRange = function(range, attributes) {
      var a, b, parse, temp, xMax, xMin, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

      if (attributes == null) {
        attributes = {};
      }
      parse = function(x) {
        var val;

        val = attributes[x];
        if (val != null) {
          return val;
        }
        val = parseInt(x);
        if (!isNaN(val)) {
          return val;
        } else {
          return null;
        }
      };
      if (Object.isString(range)) {
        _ref = range.split('..'), a = _ref[0], b = _ref[1];
        if (b == null) {
          xMin = xMax = parse(a);
        } else if (b[0] === '.') {
          xMin = (_ref1 = parse(a)) != null ? _ref1 : -10000;
          if (b.length > 1) {
            xMax = (_ref2 = parse(b.slice(1)) - 1) != null ? _ref2 : 10000;
          } else {
            xMax = xMin;
          }
        } else {
          xMin = (_ref3 = parse(a)) != null ? _ref3 : -100000;
          xMax = (_ref4 = parse(b)) != null ? _ref4 : 100000;
        }
      } else if (Object.isArray(range)) {
        if (range.length === 2) {
          _ref5 = [range[0], range[1]], xMin = _ref5[0], xMax = _ref5[1];
        } else if (range.length === 1) {
          _ref6 = [range[0], range[0]], xMin = _ref6[0], xMax = _ref6[1];
        } else {
          Core.assert(false, "Invalid int range length (" + range.length + ")");
        }
        if (xMin > xMax) {
          temp = xMin;
          xMin = xMax;
          xMax = temp;
        }
      } else {
        xMin = range;
        xMax = range;
      }
      return [xMin, xMax];
    };

    Core.randRange = function(range) {
      var xMax, xMin, _ref;

      _ref = this.parseRange(range), xMin = _ref[0], xMax = _ref[1];
      return Number.random(xMin, xMax);
    };

    Core.match = function(range, x, attributes) {
      var xMax, xMin, _ref;

      if (attributes == null) {
        attributes = {};
      }
      _ref = this.parseRange(range, attributes), xMin = _ref[0], xMax = _ref[1];
      return (xMax >= x && x >= xMin);
    };

    Core.parseText = function(txt) {
      var match, regex;

      regex = /(\ยง\w+)/;
      while (true) {
        match = regex.exec(txt);
        if (match == null) {
          break;
        }
        txt = txt.replace(match[1], config.strings[match[1].from(1)].sample());
      }
      return txt;
    };

    Core.parseMentions = function(txt, entities) {
      var ent, i, mentions, name, secretMention, _i;

      mentions = [];
      for (i = _i = 0; _i < 6; i = ++_i) {
        if (txt.indexOf("$" + i) > -1) {
          ent = entities[i];
          secretMention = false;
          if (txt.indexOf("$" + i + "f") > -1) {
            name = ent != null ? ent.firstName : '';
            txt = txt.replace("$" + i + "f", name);
            secretMention = true;
          }
          if (txt.indexOf("$" + i + "l") > -1) {
            name = ent != null ? ent.lastName : '';
            txt = txt.replace("$" + i + "l", name);
            secretMention = true;
          }
          if (txt.indexOf("$" + i + "i") > -1) {
            name = ent != null ? "" + ent.firstName[0] + ". " + ent.lastName[0] + "." : '';
            txt = txt.replace("$" + i + "i", name);
            secretMention = true;
          }
          if (!secretMention) {
            name = ent != null ? ent.fullName() : '';
            txt = txt.replace("$" + i, name);
            mentions.push(ent);
          }
        }
      }
      return [txt, mentions];
    };

    Core.clamp = function(val, min, max) {
      return Math.max(Math.min(val, max), min);
    };

    Core.assert = function(exp, message) {
      if (!exp) {
        console.error(message);
        console.trace();
        debugger;
      }
    };

    return Core;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Core = Core;

  root.Proto = Proto;

  root.TextHelper = TextHelper;

}).call(this);
